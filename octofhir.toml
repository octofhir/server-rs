# OctoFHIR Server Configuration

[server]
# Network settings
host = "0.0.0.0"
port = 8888
# Timeouts in milliseconds
read_timeout_ms = 15000
write_timeout_ms = 15000
# Max request body size in bytes (1 MiB)
body_limit_bytes = 1048576

[storage]
# PostgreSQL storage configuration (required)
#
# Two configuration modes are supported:
# 1. URL mode: Set `url` to a full connection string
# 2. Separate options: Set host, port, user, password, database individually
#
# If `url` is set, it takes precedence over individual options.
[storage.postgres]
# Option 1: Full connection URL (takes precedence if set)
# url = "postgres://postgres:postgres@localhost:5450/octofhir"

# Option 2: Separate connection options
host = "localhost"
port = 5450
user = "postgres"
password = "postgres"
database = "octofhir"

# Connection pool settings
pool_size = 20
connect_timeout_ms = 10000
idle_timeout_ms = 60000

[fhir]
# Supported: R4 (default), R4B, R5, R6
version = "R4"

[validation]
# Allow clients to skip validation via X-Skip-Validation header
# Useful for bulk imports, testing, or high-performance scenarios
allow_skip_validation = true

[search]
# Default and max page sizes
default_count = 10
max_count = 100

[packages]
# Base directory for canonical manager storage (packages/, index/, cache/ will be created here)
path = ".fhir"
# Load canonical packages by id#version (or path via table form in custom files)
load = [
  "hl7.fhir.r4.core#4.0.1"
]

[logging]
# trace | debug | info | warn | error | off
level = "info"

[otel]
# Enable OpenTelemetry tracing export
enabled = false
# Endpoint URL, e.g., "http://localhost:4318"
endpoint = ""
# Optional sampling ratio between 0.0 and 1.0
sample_ratio = 0.0

# =============================================================================
# Authentication & Authorization (SMART on FHIR / OAuth 2.0)
# =============================================================================

[auth]
# Enable the authentication module
enabled = true
# Issuer URL for tokens (should match your server's public URL)
issuer = "http://localhost:8888"

[auth.oauth]
# OAuth 2.0 token lifetimes
authorization_code_lifetime = "10m"
access_token_lifetime = "1h"
refresh_token_lifetime = "90d"
# Rotate refresh tokens on each use (security best practice)
refresh_token_rotation = true
# Allowed OAuth grant types
grant_types = ["authorization_code", "client_credentials", "refresh_token"]

[auth.smart]
# SMART on FHIR launch modes
launch_ehr_enabled = true
launch_standalone_enabled = true
# Client types
public_clients_allowed = true
confidential_symmetric_allowed = true
confidential_asymmetric_allowed = true
# Token features
refresh_tokens_enabled = true
openid_enabled = true
# Dynamic client registration (RFC 7591)
dynamic_registration_enabled = false
# Advertised scopes
supported_scopes = [
    "openid",
    "fhirUser",
    "launch",
    "launch/patient",
    "launch/encounter",
    "offline_access",
    "online_access",
    "patient/*.cruds",
    "user/*.cruds",
    "system/*.cruds",
]

[auth.signing]
# JWT signing algorithm: RS256, RS384, or ES384
algorithm = "ES384"
# Key rotation period in days
key_rotation_days = 90
# Number of old keys to retain for validation
keys_to_keep = 3

# Optional: Provide your own signing keys to persist tokens across server restarts
# If not set, a new key will be generated on each server start (tokens will be invalidated)
#
# To generate RSA keys (for RS256 or RS384) in PKCS#8 format:
#   openssl genpkey -algorithm RSA -out private.pem -pkeyopt rsa_keygen_bits:2048
#   openssl rsa -in private.pem -pubout -out public.pem
#
# To generate EC keys (for ES384) in PKCS#8 format:
#   openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-384 -out private.pem
#   openssl ec -in private.pem -pubout -out public.pem
#
# Note: Keys must be in PKCS#8 format (-----BEGIN PRIVATE KEY-----), not traditional format.
# If you have a key in traditional format, convert it:
#   openssl pkcs8 -topk8 -nocrypt -in old_private.pem -out private.pem
#
# Then paste the contents (including BEGIN/END markers) below:
#
# private_key_pem = """
# -----BEGIN PRIVATE KEY-----
# ...
# -----END PRIVATE KEY-----
# """
#
# public_key_pem = """
# -----BEGIN PUBLIC KEY-----
# ...
# -----END PUBLIC KEY-----
# """
#
# Optional: Set a stable key ID (recommended when using fixed keys)
kid = "production-key-2024"

private_key_pem = """
-----BEGIN PRIVATE KEY-----
MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDDlHNrNl0aERfdGTnY5
lyrffnjnOl/HJrT8IZIAqJ2bpJLsSjOjEHjiBnJObKnKaAihZANiAAQ+PY3EVCK7
ju3cLV0ngCgy9XSXX9L+A7EfDg/OTMk4gchL6mhDdpHe6pVsdqVeJvTxbbJPLdCU
Yg1KcVPNzZ78n3tZ6mQ0gih7J3tdwe7y26xQIzYH9a3YOx7QOdEEfx4=
-----END PRIVATE KEY-----
"""

public_key_pem = """
-----BEGIN PUBLIC KEY-----
MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEPj2NxFQiu47t3C1dJ4AoMvV0l1/S/gOx
Hw4PzkzJOIHIS+poQ3aR3uqVbHalXib08W2yTy3QlGINSnFTzc2e/J97WepkNIIo
eyd7XcHu8tusUCM2B/Wt2Dse0DnRBH8e
-----END PUBLIC KEY-----
"""

[auth.policy]
# Default policy decision when no policy matches
default_deny = true
# Enable QuickJS script engine for policies
quickjs_enabled = true

[auth.policy.quickjs]
memory_limit_mb = 16
max_stack_size_kb = 256
timeout_ms = 100

[auth.federation]
# Allow tokens from external identity providers
allow_external_idp = true
# Automatically create users from federated IdP claims
auto_provision_users = false
# JWKS cache TTL for external IdPs
jwks_cache_ttl = "1h"
jwks_refresh_on_failure = true

[auth.rate_limiting]
# Token endpoint rate limits
token_requests_per_minute = 60
token_requests_per_hour = 1000
# Authorization endpoint rate limits
auth_requests_per_minute = 30
# Lockout settings
max_failed_attempts = 5
lockout_duration = "5m"

[auth.audit]
# Audit logging settings
log_successful_auth = true
log_failed_auth = true
log_access_decisions = true
log_token_operations = true

# =============================================================================
# Redis Cache Configuration (for horizontal scaling)
# =============================================================================

[redis]
# Enable Redis caching (set to true for multi-instance deployments)
enabled = false
# Redis connection URL (matches docker-compose.yml configuration)
url = "redis://localhost:6380"
# Connection pool size
pool_size = 10
# Connection timeout in milliseconds
timeout_ms = 5000

[cache]
# Terminology cache TTL in seconds (1 hour)
terminology_ttl_secs = 3600
# Local (L1) cache max entries
local_cache_max_entries = 10000

# =============================================================================
# DB Console Configuration (SQL execution and LSP)
# =============================================================================

[db_console]
# Enable DB console functionality
enabled = true
# SQL execution mode: "readonly" | "readwrite" | "admin"
sql_mode = "admin"
# Required role for DB console access (comment out for any authenticated user)
# required_role = "admin"
# Enable LSP features (autocomplete, hover, diagnostics)
lsp_enabled = true

# =============================================================================
# GraphQL Configuration (FHIR GraphQL API)
# =============================================================================

[graphql]
# Enable GraphQL endpoint at /$graphql (and /fhir/{type}/{id}/$graphql for instance queries)
enabled = true
# Enable introspection queries (__schema, __type)
# May want to disable in production for security
introspection = true
# Maximum query depth to prevent deeply nested queries
max_depth = 15
# Maximum query complexity score
max_complexity = 500

# =============================================================================
# Bootstrap Configuration (initial server setup)
# =============================================================================

[bootstrap.admin_user]
# Admin user created on first startup if not already exists
# Credentials can also be set via environment variables:
#   OCTOFHIR__BOOTSTRAP__ADMIN_USER__USERNAME
#   OCTOFHIR__BOOTSTRAP__ADMIN_USER__PASSWORD
#   OCTOFHIR__BOOTSTRAP__ADMIN_USER__EMAIL
username = "admin"
password = "admin123"
email = "admin@octofhir.io"
